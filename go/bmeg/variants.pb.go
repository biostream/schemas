// Code generated by protoc-gen-go. DO NOT EDIT.
// source: bmeg/variants.proto

package bmeg

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This metadata represents VCF header information.
type VariantSetMetadata struct {
	// The top-level key.
	Key string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	// The value field for simple metadata.
	Value string `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
	// User-provided ID field, not enforced by this API.
	// Two or more pieces of structured metadata with identical
	// id and key fields are considered equivalent.
	// FIXME: If it's not enforced, then why can't it be null?
	Id string `protobuf:"bytes,3,opt,name=id" json:"id,omitempty"`
	// The type of data.
	Type string `protobuf:"bytes,4,opt,name=type" json:"type,omitempty"`
	// The number of values that can be included in a field described by this
	// metadata.
	Number string `protobuf:"bytes,5,opt,name=number" json:"number,omitempty"`
	// A textual description of this metadata.
	Description string `protobuf:"bytes,6,opt,name=description" json:"description,omitempty"`
	// // A map of additional information about the metadata record.
	// google.protobuf.Struct attributes = 8;
	Attributes map[string]string `protobuf:"bytes,8,rep,name=attributes" json:"attributes,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *VariantSetMetadata) Reset()                    { *m = VariantSetMetadata{} }
func (m *VariantSetMetadata) String() string            { return proto.CompactTextString(m) }
func (*VariantSetMetadata) ProtoMessage()               {}
func (*VariantSetMetadata) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{0} }

func (m *VariantSetMetadata) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *VariantSetMetadata) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *VariantSetMetadata) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *VariantSetMetadata) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *VariantSetMetadata) GetNumber() string {
	if m != nil {
		return m.Number
	}
	return ""
}

func (m *VariantSetMetadata) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *VariantSetMetadata) GetAttributes() map[string]string {
	if m != nil {
		return m.Attributes
	}
	return nil
}

// A VariantSet is a collection of variants and variant calls intended to be
// analyzed together.
type VariantSet struct {
	// The variant set ID.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// The variant set name.
	Name string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	// The ID of the dataset this variant set belongs to.
	DatasetId string `protobuf:"bytes,3,opt,name=dataset_id,json=datasetId" json:"dataset_id,omitempty"`
	// The ID of the reference set that describes the sequences used by the
	// variants in this set.
	ReferenceSetId string `protobuf:"bytes,4,opt,name=reference_set_id,json=referenceSetId" json:"reference_set_id,omitempty"`
	// Optional metadata associated with this variant set.
	// This array can be used to store information about the variant set, such as
	// information found in VCF header fields, that isn't already available in
	// first class fields such as "name".
	Metadata []*VariantSetMetadata `protobuf:"bytes,5,rep,name=metadata" json:"metadata,omitempty"`
}

func (m *VariantSet) Reset()                    { *m = VariantSet{} }
func (m *VariantSet) String() string            { return proto.CompactTextString(m) }
func (*VariantSet) ProtoMessage()               {}
func (*VariantSet) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{1} }

func (m *VariantSet) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *VariantSet) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *VariantSet) GetDatasetId() string {
	if m != nil {
		return m.DatasetId
	}
	return ""
}

func (m *VariantSet) GetReferenceSetId() string {
	if m != nil {
		return m.ReferenceSetId
	}
	return ""
}

func (m *VariantSet) GetMetadata() []*VariantSetMetadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

// A CallSet is a collection of calls that were generated by the same analysis
// of the same sample.
type CallSet struct {
	// The call set ID.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// The call set name.
	Name string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	// The Biosample the call set data was generated from.
	BiosampleId string `protobuf:"bytes,3,opt,name=biosample_id,json=biosampleId" json:"biosample_id,omitempty"`
	// The IDs of the variant sets this call set has calls in.
	VariantSetIds []string `protobuf:"bytes,4,rep,name=variant_set_ids,json=variantSetIds" json:"variant_set_ids,omitempty"`
	// The date this call set was created in milliseconds from the epoch.
	Created int64 `protobuf:"varint,5,opt,name=created" json:"created,omitempty"`
	// The time at which this call set was last updated in
	// milliseconds from the epoch.
	Updated int64  `protobuf:"varint,6,opt,name=updated" json:"updated,omitempty"`
	Method  string `protobuf:"bytes,7,opt,name=method" json:"method,omitempty"`
	Source  string `protobuf:"bytes,9,opt,name=source" json:"source,omitempty"`
}

func (m *CallSet) Reset()                    { *m = CallSet{} }
func (m *CallSet) String() string            { return proto.CompactTextString(m) }
func (*CallSet) ProtoMessage()               {}
func (*CallSet) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{2} }

func (m *CallSet) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *CallSet) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CallSet) GetBiosampleId() string {
	if m != nil {
		return m.BiosampleId
	}
	return ""
}

func (m *CallSet) GetVariantSetIds() []string {
	if m != nil {
		return m.VariantSetIds
	}
	return nil
}

func (m *CallSet) GetCreated() int64 {
	if m != nil {
		return m.Created
	}
	return 0
}

func (m *CallSet) GetUpdated() int64 {
	if m != nil {
		return m.Updated
	}
	return 0
}

func (m *CallSet) GetMethod() string {
	if m != nil {
		return m.Method
	}
	return ""
}

func (m *CallSet) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

// A `Call` represents the determination of genotype with respect to a
// particular `Variant`.
//
// It may include associated information such as quality
// and phasing. For example, a call might assign a probability of 0.32 to
// the occurrence of a SNP named rs1234 in a call set with the name NA12345.
type Call struct {
	// The name of the call set this variant call belongs to.
	// If this field is not present, the ordering of the call sets from a
	// `SearchCallSetsRequest` over this `VariantSet` is guaranteed to match
	// the ordering of the calls on this `Variant`.
	// The number of results will also be the same.
	CallSetName string `protobuf:"bytes,1,opt,name=call_set_name,json=callSetName" json:"call_set_name,omitempty"`
	// The ID of the call set this variant call belongs to.
	//
	// If this field is not present, the ordering of the call sets from a
	// `SearchCallSetsRequest` over this `VariantSet` is guaranteed to match
	// the ordering of the calls on this `Variant`.
	// The number of results will also be the same.
	CallSetId   string `protobuf:"bytes,2,opt,name=call_set_id,json=callSetId" json:"call_set_id,omitempty"`
	Method      string `protobuf:"bytes,6,opt,name=method" json:"method,omitempty"`
	Source      string `protobuf:"bytes,3,opt,name=source" json:"source,omitempty"`
	BiosampleId string `protobuf:"bytes,9,opt,name=biosample_id,json=biosampleId" json:"biosample_id,omitempty"`
	// If this field is populated, this variant call's genotype ordering implies
	// the phase of the bases and is consistent with any other variant calls on
	// the same contig which have the same phaseset string.
	Phaseset string `protobuf:"bytes,4,opt,name=phaseset" json:"phaseset,omitempty"`
	// The genotype likelihoods for this variant call. Each array entry
	// represents how likely a specific genotype is for this call as
	// log10(P(data | genotype)), analogous to the GL tag in the VCF spec. The
	// value ordering is defined by the GL tag in the VCF spec.
	GenotypeLikelihood []float64 `protobuf:"fixed64,5,rep,packed,name=genotype_likelihood,json=genotypeLikelihood" json:"genotype_likelihood,omitempty"`
}

func (m *Call) Reset()                    { *m = Call{} }
func (m *Call) String() string            { return proto.CompactTextString(m) }
func (*Call) ProtoMessage()               {}
func (*Call) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{3} }

func (m *Call) GetCallSetName() string {
	if m != nil {
		return m.CallSetName
	}
	return ""
}

func (m *Call) GetCallSetId() string {
	if m != nil {
		return m.CallSetId
	}
	return ""
}

func (m *Call) GetMethod() string {
	if m != nil {
		return m.Method
	}
	return ""
}

func (m *Call) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *Call) GetBiosampleId() string {
	if m != nil {
		return m.BiosampleId
	}
	return ""
}

func (m *Call) GetPhaseset() string {
	if m != nil {
		return m.Phaseset
	}
	return ""
}

func (m *Call) GetGenotypeLikelihood() []float64 {
	if m != nil {
		return m.GenotypeLikelihood
	}
	return nil
}

// A `Variant` represents a change in DNA sequence relative to some reference.
// For example, a variant could represent a SNP or an insertion.
// Variants belong to a `VariantSet`.
// This is equivalent to a row in VCF.
type Variant struct {
	// The variant ID.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// The ID of the `VariantSet` this variant belongs to. This transitively
	// defines
	// the `ReferenceSet` against which the `Variant` is to be interpreted.
	VariantSetId string `protobuf:"bytes,2,opt,name=variant_set_id,json=variantSetId" json:"variant_set_id,omitempty"`
	// Names for the variant, for example a RefSNP ID.
	Names []string `protobuf:"bytes,3,rep,name=names" json:"names,omitempty"`
	// The date this variant was created in milliseconds from the epoch.
	Created int64 `protobuf:"varint,4,opt,name=created" json:"created,omitempty"`
	// The time at which this variant was last updated in
	// milliseconds from the epoch.
	Updated int64 `protobuf:"varint,5,opt,name=updated" json:"updated,omitempty"`
	// The reference on which this variant occurs.
	// (e.g. `chr20` or `X`)
	ReferenceName string `protobuf:"bytes,6,opt,name=reference_name,json=referenceName" json:"reference_name,omitempty"`
	// The start position at which this variant occurs (0-based).
	// This corresponds to the first base of the string of reference bases.
	// Genomic positions are non-negative integers less than reference length.
	// Variants spanning the join of circular genomes are represented as
	// two variants one on each side of the join (position 0).
	Start int64 `protobuf:"varint,7,opt,name=start" json:"start,omitempty"`
	// The end position (exclusive), resulting in [start, end) closed-open
	// interval.
	// This is typically calculated by `start + referenceBases.length`.
	End int64 `protobuf:"varint,8,opt,name=end" json:"end,omitempty"`
	// The reference bases for this variant. They start at the given start
	// position.
	ReferenceBases string `protobuf:"bytes,9,opt,name=reference_bases,json=referenceBases" json:"reference_bases,omitempty"`
	// The bases that appear instead of the reference bases. Multiple alternate
	// alleles are possible.
	AlternateBases []string `protobuf:"bytes,10,rep,name=alternate_bases,json=alternateBases" json:"alternate_bases,omitempty"`
	// The variant calls for this particular variant. Each one represents the
	// determination of genotype with respect to this variant. `Call`s in this
	// array are implicitly associated with this `Variant`.
	Calls []*Call `protobuf:"bytes,12,rep,name=calls" json:"calls,omitempty"`
	// The "variant_type" is used to denote e.g. structural variants.
	// Examples:
	//   DUP  : duplication of sequence following "start"; not necessarily in situ
	//   DEL  : deletion of sequence following "start"
	VariantType string `protobuf:"bytes,17,opt,name=variant_type,json=variantType" json:"variant_type,omitempty"`
	// Length of the - if labeled as such in variant_type - structural variation.
	// Based on the use in VCFv4.2
	Svlen int64 `protobuf:"varint,18,opt,name=svlen" json:"svlen,omitempty"`
	// In the case of structural variants, start and end of the variant may not
	// be known with an exact base position. "cipos" provides an interval with
	// high confidence for the start position. The interval is provided by 0 or
	// 2 signed integers which are added to the start position.
	// Based on the use in VCFv4.2
	// Example:
	//   [ -12000, 1000 ]
	Cipos []int32 `protobuf:"zigzag32,19,rep,packed,name=cipos" json:"cipos,omitempty"`
	// Similar to "cipos", but for the variant's end position (which is derived
	// from start + svlen).
	// Example:
	//   [ -1000, 0 ]
	Ciend []int32 `protobuf:"zigzag32,20,rep,packed,name=ciend" json:"ciend,omitempty"`
	// True if filters were applied for this variant. VCF column 7 "FILTER"
	// any value other than the missing value.
	FiltersApplied bool `protobuf:"varint,14,opt,name=filters_applied,json=filtersApplied" json:"filters_applied,omitempty"`
	// True if all filters for this variant passed. VCF column 7 "FILTER"
	// value PASS.
	FiltersPassed bool `protobuf:"varint,15,opt,name=filters_passed,json=filtersPassed" json:"filters_passed,omitempty"`
	// Zero or more filters that failed for this variant. VCF column 7 "FILTER"
	// shared across all alleles in the same VCF record.
	FiltersFailed []string `protobuf:"bytes,16,rep,name=filters_failed,json=filtersFailed" json:"filters_failed,omitempty"`
	Source        string   `protobuf:"bytes,21,opt,name=source" json:"source,omitempty"`
}

func (m *Variant) Reset()                    { *m = Variant{} }
func (m *Variant) String() string            { return proto.CompactTextString(m) }
func (*Variant) ProtoMessage()               {}
func (*Variant) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{4} }

func (m *Variant) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Variant) GetVariantSetId() string {
	if m != nil {
		return m.VariantSetId
	}
	return ""
}

func (m *Variant) GetNames() []string {
	if m != nil {
		return m.Names
	}
	return nil
}

func (m *Variant) GetCreated() int64 {
	if m != nil {
		return m.Created
	}
	return 0
}

func (m *Variant) GetUpdated() int64 {
	if m != nil {
		return m.Updated
	}
	return 0
}

func (m *Variant) GetReferenceName() string {
	if m != nil {
		return m.ReferenceName
	}
	return ""
}

func (m *Variant) GetStart() int64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *Variant) GetEnd() int64 {
	if m != nil {
		return m.End
	}
	return 0
}

func (m *Variant) GetReferenceBases() string {
	if m != nil {
		return m.ReferenceBases
	}
	return ""
}

func (m *Variant) GetAlternateBases() []string {
	if m != nil {
		return m.AlternateBases
	}
	return nil
}

func (m *Variant) GetCalls() []*Call {
	if m != nil {
		return m.Calls
	}
	return nil
}

func (m *Variant) GetVariantType() string {
	if m != nil {
		return m.VariantType
	}
	return ""
}

func (m *Variant) GetSvlen() int64 {
	if m != nil {
		return m.Svlen
	}
	return 0
}

func (m *Variant) GetCipos() []int32 {
	if m != nil {
		return m.Cipos
	}
	return nil
}

func (m *Variant) GetCiend() []int32 {
	if m != nil {
		return m.Ciend
	}
	return nil
}

func (m *Variant) GetFiltersApplied() bool {
	if m != nil {
		return m.FiltersApplied
	}
	return false
}

func (m *Variant) GetFiltersPassed() bool {
	if m != nil {
		return m.FiltersPassed
	}
	return false
}

func (m *Variant) GetFiltersFailed() []string {
	if m != nil {
		return m.FiltersFailed
	}
	return nil
}

func (m *Variant) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

// A transcript effect record is a set of information describing the effect of
// an allele on a transcript
type TranscriptEffect struct {
	//  The ID of the transcript effect record
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// The id of the transcript feature the annotation is relative to.
	// TODO: derive unique id from digest of data [location, allele, transcript?]
	FeatureId string `protobuf:"bytes,2,opt,name=feature_id,json=featureId" json:"feature_id,omitempty"`
	// Alternate allele - a variant may have more than one alternate allele,
	// each of which will have distinct annotation.
	AlternateBases string `protobuf:"bytes,3,opt,name=alternate_bases,json=alternateBases" json:"alternate_bases,omitempty"`
	// Effect of variant on this feature.
	Effects []*OntologyTerm `protobuf:"bytes,4,rep,name=effects" json:"effects,omitempty"`
}

func (m *TranscriptEffect) Reset()                    { *m = TranscriptEffect{} }
func (m *TranscriptEffect) String() string            { return proto.CompactTextString(m) }
func (*TranscriptEffect) ProtoMessage()               {}
func (*TranscriptEffect) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{5} }

func (m *TranscriptEffect) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *TranscriptEffect) GetFeatureId() string {
	if m != nil {
		return m.FeatureId
	}
	return ""
}

func (m *TranscriptEffect) GetAlternateBases() string {
	if m != nil {
		return m.AlternateBases
	}
	return ""
}

func (m *TranscriptEffect) GetEffects() []*OntologyTerm {
	if m != nil {
		return m.Effects
	}
	return nil
}

// A `VariantAnnotation` record represents the result of comparing a variant to
// a set of reference data.
type VariantAnnotation struct {
	// The ID of this VariantAnnotation.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// The variant ID.
	VariantId string `protobuf:"bytes,2,opt,name=variant_id,json=variantId" json:"variant_id,omitempty"`
	// The ID of the variant annotation set this record belongs to.
	VariantAnnotationSetId string `protobuf:"bytes,3,opt,name=variant_annotation_set_id,json=variantAnnotationSetId" json:"variant_annotation_set_id,omitempty"`
	// The time at which this record was created, in ISO 8601 format.
	Created string `protobuf:"bytes,4,opt,name=created" json:"created,omitempty"`
	// The transcript effect annotation for the alleles of this variant. Each
	// one represents the effect of a single allele on a single transcript.
	TranscriptEffects []*TranscriptEffect `protobuf:"bytes,5,rep,name=transcript_effects,json=transcriptEffects" json:"transcript_effects,omitempty"`
}

func (m *VariantAnnotation) Reset()                    { *m = VariantAnnotation{} }
func (m *VariantAnnotation) String() string            { return proto.CompactTextString(m) }
func (*VariantAnnotation) ProtoMessage()               {}
func (*VariantAnnotation) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{6} }

func (m *VariantAnnotation) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *VariantAnnotation) GetVariantId() string {
	if m != nil {
		return m.VariantId
	}
	return ""
}

func (m *VariantAnnotation) GetVariantAnnotationSetId() string {
	if m != nil {
		return m.VariantAnnotationSetId
	}
	return ""
}

func (m *VariantAnnotation) GetCreated() string {
	if m != nil {
		return m.Created
	}
	return ""
}

func (m *VariantAnnotation) GetTranscriptEffects() []*TranscriptEffect {
	if m != nil {
		return m.TranscriptEffects
	}
	return nil
}

func init() {
	proto.RegisterType((*VariantSetMetadata)(nil), "bmeg.VariantSetMetadata")
	proto.RegisterType((*VariantSet)(nil), "bmeg.VariantSet")
	proto.RegisterType((*CallSet)(nil), "bmeg.CallSet")
	proto.RegisterType((*Call)(nil), "bmeg.Call")
	proto.RegisterType((*Variant)(nil), "bmeg.Variant")
	proto.RegisterType((*TranscriptEffect)(nil), "bmeg.TranscriptEffect")
	proto.RegisterType((*VariantAnnotation)(nil), "bmeg.VariantAnnotation")
}

func init() { proto.RegisterFile("bmeg/variants.proto", fileDescriptor5) }

var fileDescriptor5 = []byte{
	// 828 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x55, 0xdb, 0x6a, 0x23, 0x47,
	0x10, 0x65, 0x34, 0xba, 0x96, 0xac, 0x5b, 0xdb, 0x31, 0x1d, 0x83, 0x83, 0x22, 0x72, 0xd1, 0x43,
	0x90, 0xc1, 0xc9, 0x43, 0x12, 0xc8, 0x83, 0x13, 0x1c, 0x56, 0xb0, 0x37, 0xc6, 0x66, 0x5f, 0x45,
	0x6b, 0xba, 0x64, 0x37, 0x1e, 0xcd, 0x0c, 0xd3, 0x2d, 0x81, 0xfe, 0x64, 0xdf, 0xf7, 0x03, 0xf6,
	0x17, 0xf6, 0x43, 0x96, 0xfd, 0x80, 0xfd, 0x8a, 0xa5, 0x2f, 0x33, 0x1a, 0x49, 0x36, 0xf8, 0xad,
	0xeb, 0x54, 0x69, 0xba, 0xce, 0x39, 0x55, 0x2d, 0x38, 0x9e, 0x2f, 0xf1, 0xee, 0x62, 0xcd, 0x32,
	0xc1, 0x62, 0x25, 0x27, 0x69, 0x96, 0xa8, 0x84, 0x54, 0x35, 0x78, 0x66, 0x53, 0x61, 0x24, 0x62,
	0x11, 0xb2, 0xc8, 0xa6, 0x46, 0x1f, 0x2a, 0x40, 0xde, 0xd9, 0xea, 0x1b, 0x54, 0xaf, 0x50, 0x31,
	0xce, 0x14, 0x23, 0x7d, 0xf0, 0x1f, 0x70, 0x43, 0xbd, 0xa1, 0x37, 0x6e, 0x05, 0xfa, 0x48, 0x4e,
	0xa0, 0xb6, 0x66, 0xd1, 0x0a, 0x69, 0xc5, 0x60, 0x36, 0x20, 0x5d, 0xa8, 0x08, 0x4e, 0x7d, 0x03,
	0x55, 0x04, 0x27, 0x04, 0xaa, 0x6a, 0x93, 0x22, 0xad, 0x1a, 0xc4, 0x9c, 0xc9, 0x29, 0xd4, 0xe3,
	0xd5, 0x72, 0x8e, 0x19, 0xad, 0x19, 0xd4, 0x45, 0x64, 0x08, 0x6d, 0x8e, 0x32, 0xcc, 0x44, 0xaa,
	0x44, 0x12, 0xd3, 0xba, 0x49, 0x96, 0x21, 0xf2, 0x02, 0x80, 0x29, 0x95, 0x89, 0xf9, 0x4a, 0xa1,
	0xa4, 0xcd, 0xa1, 0x3f, 0x6e, 0x5f, 0x8e, 0x27, 0x9a, 0xc6, 0xe4, 0xb0, 0xe7, 0xc9, 0x55, 0x51,
	0x7a, 0x1d, 0xab, 0x6c, 0x13, 0x94, 0x7e, 0x7b, 0xf6, 0x0f, 0xf4, 0xf6, 0xd2, 0xcf, 0xa5, 0xf8,
	0x77, 0xe5, 0x4f, 0x6f, 0xf4, 0xd1, 0x03, 0xd8, 0xde, 0xe8, 0x58, 0x7b, 0x65, 0xd6, 0x31, 0x5b,
	0xe6, 0xbf, 0x33, 0x67, 0x72, 0x0e, 0xa0, 0xbb, 0x92, 0xa8, 0x66, 0x85, 0x42, 0x2d, 0x87, 0x4c,
	0x39, 0x19, 0x43, 0x3f, 0xc3, 0x05, 0x66, 0x18, 0x87, 0x38, 0x73, 0x45, 0x56, 0xb4, 0x6e, 0x81,
	0xdf, 0x98, 0xca, 0x3f, 0xa0, 0xb9, 0x74, 0x14, 0x69, 0xcd, 0x48, 0x40, 0x9f, 0x92, 0x20, 0x28,
	0x2a, 0x47, 0x9f, 0x3d, 0x68, 0xfc, 0xc7, 0xa2, 0xe8, 0xb9, 0xed, 0xfe, 0x08, 0x47, 0x73, 0x91,
	0x48, 0xb6, 0x4c, 0x23, 0xdc, 0x36, 0xdc, 0x2e, 0xb0, 0x29, 0x27, 0xbf, 0x40, 0xcf, 0xcd, 0x95,
	0x6b, 0x58, 0xd2, 0xea, 0xd0, 0x1f, 0xb7, 0x82, 0xce, 0xba, 0xe8, 0x64, 0xca, 0x25, 0xa1, 0xd0,
	0x08, 0x33, 0x64, 0x0a, 0xb9, 0x31, 0xdc, 0x0f, 0xf2, 0x50, 0x67, 0x56, 0x29, 0x37, 0x99, 0xba,
	0xcd, 0xb8, 0x50, 0xcf, 0xc8, 0x12, 0xd5, 0x7d, 0xc2, 0x69, 0xc3, 0xce, 0x88, 0x8d, 0x34, 0x2e,
	0x93, 0x55, 0x16, 0x22, 0x6d, 0x59, 0xdc, 0x46, 0xa3, 0xaf, 0x1e, 0x54, 0x35, 0x3d, 0x32, 0x82,
	0x4e, 0xc8, 0xa2, 0xc8, 0x74, 0x64, 0x48, 0x59, 0x9a, 0xed, 0xd0, 0x72, 0x7f, 0xad, 0xb9, 0xfd,
	0x00, 0xed, 0xa2, 0x46, 0x70, 0x47, 0xbb, 0xe5, 0x2a, 0xa6, 0xe5, 0xcb, 0xeb, 0x4f, 0x5c, 0xee,
	0x97, 0x2f, 0x3f, 0xd0, 0xaa, 0x75, 0xa8, 0xd5, 0x19, 0x34, 0xd3, 0x7b, 0x26, 0x51, 0xa2, 0x72,
	0xb6, 0x16, 0x31, 0xb9, 0x80, 0xe3, 0x3b, 0x8c, 0x13, 0xbd, 0x1b, 0xb3, 0x48, 0x3c, 0x60, 0x24,
	0xee, 0x93, 0x84, 0x1b, 0x6f, 0xbd, 0x80, 0xe4, 0xa9, 0x97, 0x45, 0x66, 0xf4, 0xa9, 0x0a, 0x0d,
	0x67, 0xf6, 0x81, 0x97, 0x3f, 0x41, 0x77, 0xd7, 0x14, 0x47, 0xef, 0xa8, 0xec, 0x89, 0x9e, 0x6c,
	0x2d, 0x8e, 0xa4, 0xbe, 0x31, 0xcc, 0x06, 0x65, 0xa3, 0xaa, 0x4f, 0x1a, 0x55, 0xdb, 0x35, 0xea,
	0x67, 0xd8, 0xce, 0xa7, 0x15, 0xdc, 0x6a, 0xd6, 0x29, 0x50, 0x23, 0xf9, 0x09, 0xd4, 0xa4, 0x62,
	0x99, 0x32, 0x76, 0xfa, 0x81, 0x0d, 0xf4, 0xca, 0x61, 0xcc, 0x69, 0xd3, 0x60, 0xfa, 0x48, 0x7e,
	0x85, 0xde, 0xf6, 0x73, 0x73, 0x2d, 0x90, 0x53, 0x73, 0x7b, 0xcb, 0xbf, 0x1a, 0xd5, 0x85, 0x2c,
	0x52, 0x98, 0xc5, 0x4c, 0xe5, 0x85, 0x60, 0xb8, 0x74, 0x0b, 0xd8, 0x16, 0x0e, 0xa1, 0xa6, 0x9d,
	0x95, 0xf4, 0xc8, 0xec, 0x0a, 0xd8, 0x5d, 0xd1, 0xb3, 0x12, 0xd8, 0x84, 0xb6, 0x2f, 0x97, 0xcc,
	0xbc, 0x55, 0x03, 0x6b, 0x9f, 0xc3, 0x6e, 0xf5, 0x93, 0xa5, 0xdb, 0x5f, 0x47, 0x18, 0x53, 0xe2,
	0xda, 0xd7, 0x81, 0x46, 0x43, 0x91, 0x26, 0x92, 0x1e, 0x0f, 0xfd, 0xf1, 0x20, 0xb0, 0x81, 0x45,
	0x35, 0xad, 0x93, 0x1c, 0x75, 0xc4, 0x16, 0x42, 0x77, 0x26, 0x67, 0x2c, 0x4d, 0x23, 0x81, 0x9c,
	0x76, 0x87, 0xde, 0xb8, 0x19, 0x74, 0x1d, 0x7c, 0x65, 0x51, 0x2d, 0x68, 0x5e, 0x98, 0x32, 0x29,
	0x91, 0xd3, 0x9e, 0xa9, 0xeb, 0x38, 0xf4, 0xad, 0x01, 0xcb, 0x65, 0x0b, 0x26, 0x22, 0xe4, 0xb4,
	0x6f, 0x77, 0xcf, 0xa1, 0xff, 0x1b, 0xb0, 0x34, 0xb2, 0xdf, 0xed, 0xec, 0xcb, 0x7b, 0x0f, 0xfa,
	0xb7, 0x19, 0x8b, 0xed, 0xdb, 0x7a, 0xbd, 0x58, 0x60, 0x78, 0x38, 0x4b, 0xe7, 0x00, 0x0b, 0x64,
	0x6a, 0x95, 0x61, 0x69, 0x4d, 0x1c, 0x32, 0xe5, 0x8f, 0x59, 0x60, 0xf7, 0x62, 0xdf, 0x82, 0xdf,
	0xa0, 0x81, 0xe6, 0x06, 0xfb, 0x40, 0xb4, 0x2f, 0x89, 0x35, 0xe1, 0x4d, 0xac, 0x92, 0x28, 0xb9,
	0xdb, 0xdc, 0x62, 0xb6, 0x0c, 0xf2, 0x92, 0xd1, 0x17, 0x0f, 0x06, 0x6e, 0xba, 0xaf, 0xe2, 0x38,
	0x51, 0xcc, 0x3c, 0xfd, 0x8f, 0xf4, 0x96, 0x9b, 0xb6, 0xed, 0xcd, 0x21, 0x53, 0x4e, 0xfe, 0x82,
	0xef, 0xf3, 0x34, 0x2b, 0x3e, 0x32, 0xdb, 0x79, 0x7c, 0x4f, 0xd7, 0xfb, 0x97, 0xd8, 0xdd, 0xd8,
	0xdb, 0x82, 0xd6, 0x76, 0x0b, 0xae, 0x81, 0xa8, 0x42, 0xb3, 0x59, 0x4e, 0xc9, 0xbe, 0xc1, 0xa7,
	0x96, 0xd2, 0xbe, 0xa6, 0xc1, 0x40, 0xed, 0x21, 0x72, 0x5e, 0x37, 0xff, 0xb4, 0xbf, 0x7f, 0x0b,
	0x00, 0x00, 0xff, 0xff, 0x3d, 0x6c, 0x0f, 0x92, 0x9b, 0x07, 0x00, 0x00,
}
